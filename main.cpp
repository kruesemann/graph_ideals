#include <iostream>

#include "stdafx.h"
#include "DatabaseInterface.h"


#define help_text	"-- Enter 'help' to see this text. Valid arguments:\n\n" \
					"     -dbd : shows a description of the database instead\n" \
					"     -sql : shows a sample of useful SQL queries instead\n" \
					"\n-- Enter 'exit'/'quit' to exit the program.\n" \
					"\n-- Enter 'show_view' to output the current view to the terminal. Valid arguments: \n\n" \
					"     -[limit] : specifies a limit of the number of rows printed, e.g. show_view -10 (default is 100)\n" \
					"     -f       : forces output of all rows\n" \
					"     -r       : prints the view in rich format, i.e. Betti tables will be printed as actual tables\n" \
					"\n-- Enter 'save_view' to output the current view to '[output file name].view'. Valid arguments:\n\n" \
					"     -r                 : prints the view in rich format, i.e. Betti tables will be printed as actual tables\n" \
					"     -v                 : generates LaTeX-TikZ code snippets to visualize all graphs in the current view\n" \
					"     -g6                : prints all graphs in the current view in g6 format\n" \
					"     [output file name] : if no file name is given, the view will be output to 'database.view'\n" \
					"\n-- Enter 'build' to build the database. Valid arguments (the order of [ideal type] and [input file] does matter):\n\n" \
					"     -except         : executes all build operations excepts the ones specified\n" \
					"     -f              : forces update, ignores status table (Warning: may cause graphs to be labeled redundantly!)\n" \
					"     -insert         : inserts all graphs from the g6-formatted [input file], expects a file as generated by nauty\n" \
					"                       (automatically computes clique number and number of inclusion-maximal cliques)\n" \
					"     -connected      : labels all connected graphs in the database\n" \
					"     -cograph        : labels all cographs in the database\n" \
					"     -euler          : labels all euler graphs in the database\n" \
					"     -chordal        : labels all chordal graphs in the database\n" \
					"     -claw-free      : labels all claw-free graphs in the database\n" \
					"     -closed         : labels all closed graphs in the database (Warning: this requires the chordal and claw-free\n" \
					"                       graphs to be labeled, otherwise none of the graphs will be labeled 'closed')\n" \
					"     -betti          : adds columns for the Betti numbers and related invariants of the factor ring of the specified\n" \
					"                       [ideal type] and reads the data from the [input file] (this will update the graphs of order\n" \
					"                       [graph order] starting from the smallest graphID!)\n" \
					"     -cl             : causes -betti to add the data of the closed-labeling initial ideal of the specified ideal type\n" \
					"                       of all closed graphs\n" \
					"     -max            : causes [graph order] to be interpreted as the maximum graph order of which the graphs will be\n" \
					"                       updated, any missing data will be ignored\n" \
					"     -[graph order]  : specifies the graph order\n" \
					"     [input file]    : specifies the input file for inserts (not for adding of Betti data)\n" \
					"     [ideal name]    : determines the name of the Betti data columns\n" \
					"     [M2 ideal type] : must be the same as the one specified when generating Macaulay2 scripts as this program\n" \
					"                       automatically tries to open the results generated by the Macaulay2 scripts\n" \
					"\n-- Enter 'gen_m2_scripts' to generate Macaulay2 scripts to compute the Betti numbers of the factor ring of the\n" \
					"   specified graph ideal. Valid arguments:\n\n" \
					"     -cl                : generates only M2 scripts for the initial ideals of the specified ideal type of all closed\n" \
					"                          graphs in the database each labeled with regards to one of their closed orderings\n" \
					"     [M2 ideal type]    : must be a valid Macaulay2 ideal type, that takes a Graph from the M2-package 'Graphs' as\n" \
					"                          an argument\n" \
					"     -[batch size]      : specifies the maximum number of graphs per script (2500 graphs will very roughly take 2h\n" \
					"                          of computation time)\n" \
					"     [required package] : specifies a required Macaulay2 package (multiple of these arguments are possible)\n" \
					"\n-- Enter 'analyse_cones' either to generate files for all cones in the database or to compare the regularities of\n" \
					"   the cones with those of their base graphs.\n" \
					"     -gen  : generates two files, one for the graphIDs of all cones in the database and one for the g6-formatted base\n" \
					"             graphs of these cones.\n" \
					"     -comp : compares the regularity of the cones in the graphIDs file with the regularity of the now canonically\n" \
					"             labeled base graphs in the new base graph file.\n" \
					"\n-- Any other input will be interpreted as an SQL statement. The results of a query (i.e. a view) will be output to\n" \
					"   the terminal and remain in memory until another query is entered."

#define sql_sample	"Some SQL queries (note that sqlite is not case-sensitive, but this program only accepts 'SELECT', 'Select' and\n" \
					"'select' for queries):\n\n" \
					"SELECT * FROM Graphs WHERE graphOrder == 3;\n" \
					"SELECT DISTINCT graphOrder FROM Graphs WHERE beiReg == 4;\n" \
					"SELECT graphID, graphOrder, beiBettis FROM Graphs WHERE graphOrder == 7 AND beiReg == 4;\n" \
					"SELECT beiReg FROM Graphs ORDER BY beiReg DESC LIMIT 1;\n" \
					"SELECT MAX(beiReg) FROM Graphs;\n" \
					"SELECT graphOrder, count(*) FROM Graphs WHERE type LIKE \"%cograph%\" GROUP BY graphOrder;\n" \
					"SELECT t1.beiReg as coneRegularity, t2.beiReg AS oldRegularity\n" \
					"  FROM Graphs t1 INNER JOIN Graphs t2\n" \
					"  ON t2.nGraphID = t1.coneOver\n" \
					"  WHERE t1.beiReg <> t2.beiReg;\n" \
					"\n\nSQL statements to reset type and status table manually:\n\n" \
					"UPDATE Graphs SET type = NULL;\n" \
					"UPDATE Status SET checked = 0 WHERE specification == \"connected\";"

//########## IO functions ##########
/**
 * gets the user input and returns the interaction key based on the keyword of the input
**/
int io_interface(std::string * input) {
	std::cout << "\n> ";

	if (!getline(std::cin, *input))
		return 0;

	std::cout << std::endl;

	size_t cut_index = input->find_first_of(' ');
	std::string keyword = input->substr(0, cut_index);
	int key = -2;

	if (keyword == "SELECT"
		|| keyword == "Select"
		|| keyword == "select")
		key = -1;
	else if (keyword == "exit"
		|| keyword == "quit")
		key = 0;
	else if (keyword == "help")
		key = 1;
	else if (keyword == "show_view")
		key = 2;
	else if (keyword == "save_view")
		key = 3;
	else if (keyword == "build")
		key = 4;
	else if (keyword == "gen_m2_scripts")
		key = 5;
	else if (keyword == "analyse_cones")
		key = 6;

	if (key > 0)
	{
		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	return key;
}


/**
 * outputs help_text, description of the database and/or a sample of SQL queries to the terminal
**/
void help_parse(DatabaseInterface * dbi, std::string * input) {
	bool dbd = false;
	bool sql = false;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-dbd")
			dbd = true;
		else if (arg == "-sql")
			sql = true;
		else{
			std::cout << "Parse error: " << arg << " is not a valid argument." << std::endl;
			return;
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (!dbd && !sql)
		std::cout << "\n" << help_text << "\n";
	if (dbd)
	{
		std::cout << "\n";
		dbi->show_status();
		std::cout << "\n";
	}
	if (sql)
		std::cout << "\n" << sql_sample << "\n";
	std::cout << std::endl;
}


/**
 * parses the arguments for show_view to decide the output format and the limit for the number of output rows, then chooses the appropriate function
**/
void show_view_parse(DatabaseInterface * dbi, std::string * input) {
	int limit = -1;
	bool force = false;
	bool rich = false;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-r")
			rich = true;
		else if (arg == "-f")
		{
			if (limit != -1)
			{
				std::cout << "Warning: " << arg << " will be ignored since a limit was already specified. Proceed? (y/n)\n> ";
				std::string extra_input;
				while (true)
				{
					getline(std::cin, extra_input);
					if (extra_input == "y")
						break;
					if (extra_input == "n")
						return;
					std::cout << "Parse error: Not a valid input.\n> ";
				}
				std::cout << std::endl;
			}
			else
				force = true;
		}
		else if (force)
		{
			std::cout << "Warning: " << arg << " will be ignored since -f was given as an argument. Proceed? (y/n)\n> ";
			std::string extra_input;
			while (true)
			{
				getline(std::cin, extra_input);
				if (extra_input == "y")
					break;
				if (extra_input == "n")
					return;
				std::cout << "Parse error: Not a valid input.\n> ";
			}
			std::cout << std::endl;
		}
		else
		{
			limit = 0;
			for (unsigned i = 1; i < arg.length(); i++)
			{
				if (arg.at(i) < '0'
					|| arg.at(i) > '9')
				{
					std::cout << "Parse error: " << arg << " is not a valid argument." << std::endl;
					return;
				}

				limit *= 10;
				limit += arg.at(i) - '0';
			}
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (force)
	{
		if (rich)
			dbi->show_view_rich(-1);
		else
			dbi->show_view(-1);
	}
	else
	{
		if (limit == -1)
		{
			if (rich)
				dbi->show_view_rich();
			else
				dbi->show_view();
		}
		else
		{
			if (rich)
				dbi->show_view_rich(limit);
			else
				dbi->show_view(limit);
		}
	}
}


/**
* parses the arguments for save_view to decide the output format and the file name, tries to open the file, then chooses the appropriate function
**/
void save_view_parse(DatabaseInterface * dbi, std::string * input) {
	std::string file_name = "database.view";
	bool rich = false;
	bool visualisation = false;
	bool g6 = false;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-r")
		{
			if (visualisation
				|| g6)
				std::cout << "Warning: " << arg << " will be ignored since another view format was already specified." << std::endl;
			else
			 rich = true;
		}
		else if (arg == "-v")
		{
			if (rich
				|| g6)
				std::cout << "Warning: " << arg << " will be ignored since another view format was already specified." << std::endl;
			else
				visualisation = true;
		}
		else if (arg == "-g6")
		{
			if (rich
				|| visualisation)
				std::cout << "Warning: " << arg << " will be ignored since another view format was already specified." << std::endl;
			else
				g6 = true;
		}
		else{
			file_name = arg + ".view";
			std::ifstream test(file_name);

			if (test.is_open())
			{
				std::cout << file_name << " already exists. Override? (y/n)\n> ";
				std::string extra_input;
				while (true)
				{
					getline(std::cin, extra_input);
					if (extra_input == "y")
						break;
					if (extra_input == "n")
					{
						test.close();
						return;
					}
					std::cout << "Parse error: Not a valid input.\n> ";
				}
			}

			test.close();
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	std::ofstream file(file_name, std::ios::trunc);

	if (!file.is_open())
	{
		std::cout << "Saving view failed. Could not open " << file_name << "." << std::endl;
		return;
	}

	if (rich)
		dbi->save_view_rich(&file);
	else if (visualisation)
		dbi->save_view_visualisation(&file);
	else if (g6)
		dbi->save_view_g6(&file);
	else
		dbi->save_view(&file);

	file.close();

	if (visualisation
		|| g6)
		std::cout << "Saved graphs in current view to " << file_name << "." << std::endl;
	else
		std::cout << "Saved current view to " << file_name << "." << std::endl;
}


/**
 * chooses the graphs to be updated
**/
bool commission_type_update(DatabaseInterface * dbi, int order, bool max, bool force, const char * print_name, const char * type, bool (Graph::*graph_test)(), const char * query_condition) {
	if (order == -1)
	{
		if (max)
		{
			std::cout << "Updating " << print_name << " failed. No maximum graph order specified." << std::endl;
			return false;
		}

		for (unsigned n = 1; true; n++)
		{
			std::cout << "   checking for " << print_name << " of order " << n << "...\n";
			if (!force
				&& dbi->checked(type, n))
				std::cout << "Update failed. The " << print_name << " of order " << order << " already labeled. Reset type and status table manually to restart all labeling or type '-f' as an argument to force the update." << std::endl;
			else if (dbi->update_type(n, graph_test, type, query_condition))
				dbi->update_status(type, n);
			else
				break;
		}
	}
	else
	{
		if (max)
		{
			for (int n = 1; n <= order; n++)
			{
				std::cout << "   checking for " << print_name << " of order " << n << "...\n";
				if (!force
					&& dbi->checked(type, n))
					std::cout << "Update failed. The " << print_name << " of order " << order << " already labeled. Reset type and status table manually to restart all labeling or type '-f' as an argument to force the update." << std::endl;
				else if (dbi->update_type(n, graph_test, type, query_condition))
					dbi->update_status(type, n);
			}
		}
		else if (!force
			&& dbi->checked(type, order))
			std::cout << "Update failed. The " << print_name << " of order " << order << " already labeled. Reset type and status table manually to restart all labeling or type '-f' as an argument to force the update." << std::endl;
		else
		{
			std::cout << "   checking for " << print_name << "...\n";
			if (dbi->update_type(order, graph_test, type, query_condition))
				dbi->update_status(type, order);
		}
	}

	return true;
}


/**
 * parses the arguments for build and looks up the status table to decide what build functions to execute
**/
void build_parse(DatabaseInterface * dbi, std::string * input) {
	dbi->create_status_table();
	dbi->create_graphs_table();

	bool except = false;
	bool force = false;
	bool insert = false;
	bool connected = false;
	bool cograph = false;
	bool euler = false;
	bool chordal = false;
	bool clawfree = false;
	bool closed = false;
	bool betti = false;
	bool cl = false;
	bool max = false;
	int order = -1;
	std::string name = "";
	std::string type = "";

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-except")
			except = true;
		else if (arg == "-f")
			force = true;
		else if (arg == "-insert")
			insert = true;
		else if (arg == "-connected")
			connected = true;
		else if (arg == "-cograph")
			cograph = true;
		else if (arg == "-euler")
			euler = true;
		else if (arg == "-chordal")
			chordal = true;
		else if (arg == "-claw-free")
			clawfree = true;
		else if (arg == "-closed")
			closed = true;
		else if (arg == "-betti")
			betti = true;
		else if (arg == "-cl")
			cl = true;
		else if (arg == "-max")
			max = true;
		else if (arg.front() == '-')
		{
			order = 0;
			for (unsigned i = 1; i < arg.length(); i++)
			{
				if (arg.at(i) < '0'
					|| arg.at(i) > '9')
				{
					std::cout << "Parse error: " << arg << " is not a valid argument." << std::endl;
					return;
				}

				order *= 10;
				order += arg.at(i) - '0';
			}
		}
		else if (name.empty())
			name = arg;
		else if (type.empty())
			type = arg;
		else
		{
			std::cout << "Parse error: Could not process argument. Either " << arg << " is not valid or there are too many." << std::endl;
			return;
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (except)
	{
		insert = !insert;
		connected = !connected;
		cograph = !cograph;
		euler = !euler;
		chordal = !chordal;
		clawfree = !clawfree;
		closed = !closed;
		betti = !betti;
	}

	if (insert)
	{
		if (!name.empty())
		{
			std::ifstream file(name);
			if (file.is_open())
			{
				try
				{
					std::cout << "   inserting graphs...\n";
					dbi->insert_graphs(&file);
				}
				catch (const char * e)
				{
					std::cerr << e << std::endl;
				}
			}
			else
			{
				std::cout << "Inserting graphs failed. Could not open " << name << "." << std::endl;
				return;
			}
			file.close();
		}
		else
		{
			std::cout << "Inserting graphs failed. No file specified." << std::endl;
			return;
		}
	}

	if (connected)
		commission_type_update(dbi, order, max, force, "connected graphs", "connected", &Graph::is_connected, 0);

	if (cograph)
		commission_type_update(dbi, order, max, force, "cographs", "cograph", &Graph::is_cograph, 0);

	if (euler)
		commission_type_update(dbi, order, max, force, "euler graphs", "euler", &Graph::is_euler, 0);

	if (chordal)
		commission_type_update(dbi, order, max, force, "chordal graphs", "chordal", &Graph::is_chordal, 0);

	if (clawfree)
		commission_type_update(dbi, order, max, force, "claw-free graphs", "claw-free", &Graph::is_clawfree, 0);

	if (closed)
		commission_type_update(dbi, order, max, force, "closed graphs", "closed", &Graph::is_closed, "type LIKE '%chordal%' AND type LIKE '%claw-free%'");

	if (betti)
	{
		if (type.empty())
		{
			if (name.empty())
			{
				std::cout << "Adding Betti data failed. No ideal type specified." << std::endl;
				return;
			}
			else
			{
				type = name;
				name = "clInit" + name;
			}
		}

		if (name.find("Bettis") == std::string::npos)
		{
			if (order == -1)
			{
				if (max)
				{
					std::cout << "Adding Betti data failed. No maximum graph order specified." << std::endl;
					return;
				}

				for (unsigned n = 1; true; n++)
				{
					std::cout << "   adding Betti data for graphs of order " << n << "...\n";
					if (cl)
					{
						if (!dbi->add_closed_labeling_betti_data(n, &name, &type))
							break;
					}
					else if (!dbi->add_betti_data(n, &name, &type))
						break;
				}
			}
			else
			{
				if (max)
				{
					for (int n = 1; n <= order; n++)
					{
						std::cout << "   adding Betti data for graphs of order " << n << "...\n";
						if (cl)
							dbi->add_closed_labeling_betti_data(n, &name, &type);
						else
							dbi->add_betti_data(n, &name, &type);
					}
				}
				else
				{
					std::cout << "   adding Betti data...\n";
					if (cl)
						dbi->add_closed_labeling_betti_data(order, &name, &type);
					else
						dbi->add_betti_data(order, &name, &type);
				}
			}
		}
		else
			std::cout << "Adding Betti data failed. Please choose a name other than " << name << " for the ideal as anything with 'Bettis' in it would interfere with the database." << std::endl;
	}
}


/**
 * parses the arguments for gen_M2_scripts and calls gen_m2_scripts with the appropriate arguments
**/
void gen_M2_scripts_parse(DatabaseInterface * dbi, std::string * input) {
	bool cl = false;
	std::string ideal_type = "";
	int batch_size = -1;
	std::vector<std::string> required_packages;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-cl")
			cl = true;
		else if (arg.front() == '-')
		{
			batch_size = 0;
			for (unsigned i = 1; i < arg.length(); i++)
			{
				if (arg.at(i) < '0'
					|| arg.at(i) > '9')
				{
					std::cout << "Parse error: " << arg << " is not a valid argument." << std::endl;
					return;
				}

				batch_size *= 10;
				batch_size += arg.at(i) - '0';
			}
		}
		else if (ideal_type.empty())
			ideal_type = arg;
		else
			required_packages.push_back(arg);

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (batch_size == -1)
	{
		std::cout << "Generating M2 scripts failed. No batch size specified." << std::endl;
		return;
	}

	if (ideal_type.empty())
	{
		std::cout << "Generating M2 scripts failed. No ideal type specified.\n" << std::endl;
		return;
	}

	if (ideal_type.find("Bettis") == std::string::npos)
	{
		if (cl)
			dbi->generate_closed_labeling_m2_scripts(&ideal_type, batch_size, &required_packages);
		else
			dbi->generate_m2_scripts(&ideal_type, batch_size, &required_packages);
	}
	else
		std::cout << "Generating M2 scripts failed. Please choose an ideal type other than " << ideal_type << " as anything with 'Bettis' in it would interfere with the database." << std::endl;
}


/**
* parses the arguments for analyse_cones and calls either generate_cone_lists or compare_cone_regularities
**/
void analyse_cones_parse(DatabaseInterface * dbi, std::string * input) {
	bool gen = false;
	bool comp = false;
	std::string filename;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-gen")
		{
			if (comp)
				std::cout << "Warning: " << arg << " will be ignored since another option was already specified." << std::endl;
			else
				gen = true;

		}
		else if (arg == "-comp")
		{
			if (gen)
				std::cout << "Warning: " << arg << " will be ignored since another option was already specified." << std::endl;
			else
				comp = true;
		}
		else if (filename.empty())
			filename = arg;
		else
		{
			std::cout << "Parse error: Could not process argument. Either " << arg << " is not valid or there are too many." << std::endl;
			return;
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (gen)
	{
		dbi->generate_cone_lists();
		return;
	}

	if (comp)
	{
		dbi->compare_cone_regularities(&filename);
		return;
	}
	
	std::cout << "Analysing cones failed. No valid argument was given." << std::endl;
}


//########## main function ##########
/**
 * opens the given database (if none is specified it opens 'Graphs.db'),
 * gets the interaction key via io_interface and takes action based on the key
**/
int main(int argc, char* argv[]) {
	std::cout << "Graphs database interface\nEnter 'help' for a description of all features\n" << std::endl;

	std::string input = "";
	DatabaseInterface dbi;

	if (argc == 2)
		dbi = DatabaseInterface(argv[1]);
	else if (argc > 2)
	{
		std::cerr << "Too many arguments." << std::endl;
		return 1;
	}
	else
		dbi = DatabaseInterface("Graphs.db");

	while (true)
	{
		int key = io_interface(&input);

		switch (key)
		{
		case 0: return 0;
		case -2: dbi.execute_SQL_statement(&input); break;
		case -1: dbi.execute_SQL_query(&input); break;
		case 1: help_parse(&dbi, &input); break;
		case 2: show_view_parse(&dbi, &input); break;
		case 3: save_view_parse(&dbi, &input); break;
		case 4: build_parse(&dbi, &input); break;
		case 5: gen_M2_scripts_parse(&dbi, &input); break;
		case 6: analyse_cones_parse(&dbi, &input); break;
		default: break;
		}
	}
}