#include <iostream>

#include "stdafx.h"
#include "DatabaseInterface.h"


#define help_text	"-- Enter 'help' to see this text. Valid arguments:\n\n" \
					"     -dbd : shows a description of the database instead\n" \
					"     -sql : shows a sample of useful SQL queries instead\n" \
					"\n-- Enter 'exit'/'quit' to exit the program.\n" \
					"\n-- Enter 'show_view' to output the current view to the terminal. Valid arguments: \n\n" \
					"     -[limit] : specifies a limit of the number of rows printed, e.g. show_view -10 (default is 100)\n" \
					"     -f       : forces output of all rows\n" \
					"     -r       : prints the view in rich format, i.e. Betti tables will be printed as actual tables\n" \
					"\n-- Enter 'save_view' to output the current view to '[output file name].view'. Valid arguments:\n\n" \
					"     -r                 : prints the view in rich format, i.e. Betti tables will be printed as actual tables\n" \
					"     -v                 : generates LaTeX-TikZ code snippets to visualize all graphs in the current view\n" \
					"     -g6                : prints all graphs in the current view in g6 format\n" \
					"     [output file name] : if no file name is given, the view will be output to 'database.view'\n" \
					"\n-- Enter 'build' to build the database. Valid arguments (the order of [ideal type] and [input file] does matter):\n\n" \
					"     -except         : executes all build operations excepts the ones specified\n" \
					"     -f              : forces update, ignores status table (Warning: may cause graphs to be labeled redundantly!)\n" \
					"     -insert         : inserts all graphs from the g6-formatted [input file], expects a file as generated by nauty\n" \
					"                       (automatically computes clique number and number of inclusion-maximal cliques)\n" \
					"     -connected      : labels all connected graphs in the database\n" \
					"     -cograph        : labels all cographs in the database\n" \
					"     -euler          : labels all euler graphs in the database\n" \
					"     -chordal        : labels all chordal graphs in the database\n" \
					"     -claw-free      : labels all claw-free graphs in the database\n" \
					"     -closed         : labels all closed graphs in the database (Warning: this requires the chordal and claw-free\n" \
					"                       graphs to be labeled, otherwise none of the graphs will be labeled 'closed')\n" \
					"     -betti          : adds columns for the Betti numbers and related invariants of the factor ring of the specified\n" \
					"                       [ideal type] and reads the data from the [input file] (this will update the graphs of order\n" \
					"                       [graph order] starting from the smallest graphID!)\n" \
					"     -cl             : causes -betti to add the data of the closed-labeling initial ideal of the specified ideal type\n" \
					"                       of all closed graphs\n" \
					"     -max            : causes [graph order] to be interpreted as the maximum graph order of which the graphs will be\n" \
					"                       updated, any missing data will be ignored\n" \
					"     -[graph order]  : specifies the graph order\n" \
					"     [input file]    : specifies the input file for inserts (not for adding of Betti data)\n" \
					"     [ideal name]    : determines the name of the Betti data columns\n" \
					"     [M2 ideal type] : must be the same as the one specified when generating Macaulay2 scripts as this program\n" \
					"                       automatically tries to open the results generated by the Macaulay2 scripts\n" \
					"\n-- Enter 'gen_m2_scripts' to generate Macaulay2 scripts to compute the Betti numbers of the factor ring of the\n" \
					"   specified graph ideal. Valid arguments:\n\n" \
					"     -cl                : generates only M2 scripts for the initial ideals of the specified ideal type of all closed\n" \
					"                          graphs in the database each labeled with regards to one of their closed orderings\n" \
					"     [M2 ideal type]    : must be a valid Macaulay2 ideal type, that takes a Graph from the M2-package 'Graphs' as\n" \
					"                          an argument\n" \
					"     -[batch size]      : specifies the maximum number of graphs per script (2500 graphs will very roughly take 2h\n" \
					"                          of computation time)\n" \
					"     [required package] : specifies a required Macaulay2 package (multiple of these arguments are possible)\n" \
					"\n-- Enter 'analyse_cones' either to generate files for all cones in the database or to compare the regularities of\n" \
					"   the cones with those of their base graphs.\n" \
					"     -gen  : generates two files, one for the graphIDs of all cones in the database and one for the g6-formatted base\n" \
					"             graphs of these cones.\n" \
					"     -comp : compares the regularity of the cones in the graphIDs file with the regularity of the now canonically\n" \
					"             labeled base graphs in the new base graph file.\n" \
					"\n-- Any other input will be interpreted as an SQL statement. The results of a query (i.e. a view) will be output to\n" \
					"   the terminal and remain in memory until another query is entered."

#define sql_sample	"Some SQL queries (note that sqlite is not case-sensitive, but this program only accepts 'SELECT', 'Select' and\n" \
					"'select' for queries):\n\n" \
					"SELECT * FROM Graphs WHERE graphOrder == 3;\n" \
					"SELECT DISTINCT graphOrder FROM Graphs WHERE beiReg == 4;\n" \
					"SELECT graphID, graphOrder, beiBettis FROM Graphs WHERE graphOrder == 7 AND beiReg == 4;\n" \
					"SELECT beiReg FROM Graphs ORDER BY beiReg DESC LIMIT 1;\n" \
					"SELECT MAX(beiReg) FROM Graphs;\n" \
					"SELECT graphOrder, count(*) FROM Graphs WHERE type LIKE \"%cograph%\" GROUP BY graphOrder;\n" \
					"SELECT t1.beiReg as coneRegularity, t2.beiReg AS oldRegularity\n" \
					"  FROM Graphs t1 INNER JOIN Graphs t2\n" \
					"  ON t2.nGraphID = t1.coneOver\n" \
					"  WHERE t1.beiReg <> t2.beiReg;\n" \
					"\n\nSQL statements to reset type and status table manually:\n\n" \
					"UPDATE Graphs SET type = NULL;\n" \
					"UPDATE Status SET checked = 0 WHERE specification == \"connected\";"


typedef bool (Graph::*Graph_test) ();
typedef unsigned* (Graph::*Gen_labeling) ();

#define NUMBER_TYPES 6
const char* TYPES[NUMBER_TYPES] = { "connected", "cograph", "euler", "chordal", "claw-free", "closed" };
const char* PRINT_NAMES[NUMBER_TYPES] = { "connected graphs", "cographs", "euler graphs", "chordal graphs", "claw-free graphs", "closed graphs" };
Graph_test TESTS[NUMBER_TYPES] = { &Graph::is_connected, &Graph::is_cograph, &Graph::is_euler, &Graph::is_chordal, &Graph::is_clawfree, &Graph::is_closed };
const char* STD_CONDITIONS[NUMBER_TYPES] = { 0, 0, 0, 0, 0, "type LIKE '%chordal%' AND type LIKE '%claw-free%'" };

#define NUMBER_LABELINGS 1
const char* LABELINGS[NUMBER_LABELINGS] = { "closed" };
Gen_labeling GENERATORS[NUMBER_LABELINGS] = { &Graph::gen_closed_labeling };


//########## IO functions ##########
/**
 * gets the user input and returns the interaction key based on the keyword of the input
**/
int io_interface(std::string * input) {
	std::cout << "\n>> ";

	if (!getline(std::cin, *input))
		return 0;

	std::cout << std::endl;

	size_t cut_index = input->find_first_of(' ');
	std::string keyword = input->substr(0, cut_index);
	int key = -2;

	if (keyword == "SELECT"
		|| keyword == "Select"
		|| keyword == "select")
		key = -1;
	else if (keyword == "exit"
		|| keyword == "quit")
		key = 0;
	else if (keyword == "help")
		key = 1;
	else if (keyword == "show")
		key = 2;
	else if (keyword == "save")
		key = 3;
	else if (keyword == "insert")
		key = 4;
	else if (keyword == "label")
		key = 5;
	else if (keyword == "betti")
		key = 6;
	else if (keyword == "scripts")
		key = 7;

	if (key > 0)
	{
		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	return key;
}


/**
 * outputs help_text, description of the database and/or a sample of SQL queries to the terminal
**/
void help_parse(DatabaseInterface * dbi, std::string * input) {
	bool dbd = false;
	bool sql = false;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-dbd")
			dbd = true;
		else if (arg == "-sql")
			sql = true;
		else{
			std::cout << "Parse error: " << arg << " is not a valid argument." << std::endl;
			return;
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (!dbd && !sql)
		std::cout << "\n" << help_text << "\n";
	if (dbd)
	{
		std::cout << "\n";
		dbi->show_status();
		std::cout << "\n";
	}
	if (sql)
		std::cout << "\n" << sql_sample << "\n";
	std::cout << std::endl;
}


/**
 * parses the arguments for show to decide the output format and the limit for the number of output rows, then chooses the appropriate function
**/
void show_parse(DatabaseInterface * dbi, std::string * input) {
	int limit = -1;
	bool force = false;
	bool rich = false;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-r")
			rich = true;
		else if (arg == "-f")
		{
			if (limit != -1)
			{
				std::cout << "Warning: " << arg << " will be ignored since a limit was already specified. Proceed? (y/n)\n>> ";
				std::string extra_input;
				while (true)
				{
					getline(std::cin, extra_input);
					if (extra_input == "y")
						break;
					if (extra_input == "n")
						return;
					std::cout << "Parse error: Not a valid input.\n>> ";
				}
				std::cout << std::endl;
			}
			else
				force = true;
		}
		else if (force)
		{
			std::cout << "Warning: " << arg << " will be ignored since -f was given as an argument. Proceed? (y/n)\n>> ";
			std::string extra_input;
			while (true)
			{
				getline(std::cin, extra_input);
				if (extra_input == "y")
					break;
				if (extra_input == "n")
					return;
				std::cout << "Parse error: Not a valid input.\n>> ";
			}
			std::cout << std::endl;
		}
		else
		{
			limit = 0;
			for (unsigned i = 1; i < arg.length(); i++)
			{
				if (arg.at(i) < '0'
					|| arg.at(i) > '9')
				{
					std::cout << "Parse error: " << arg << " is not a valid argument." << std::endl;
					return;
				}

				limit *= 10;
				limit += arg.at(i) - '0';
			}
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (force)
	{
		if (rich)
			dbi->show_view_rich(-1);
		else
			dbi->show_view(-1);
	}
	else
	{
		if (limit == -1)
		{
			if (rich)
				dbi->show_view_rich();
			else
				dbi->show_view();
		}
		else
		{
			if (rich)
				dbi->show_view_rich(limit);
			else
				dbi->show_view(limit);
		}
	}
}


/**
* parses the arguments for save to decide the output format and the file name, tries to open the file, then chooses the appropriate function
**/
void save_parse(DatabaseInterface * dbi, std::string * input) {
	std::string file_name = "database.view";
	bool rich = false;
	bool visualisation = false;
	bool g6 = false;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-r")
		{
			if (visualisation
				|| g6)
				std::cout << "Warning: " << arg << " will be ignored since another view format was already specified." << std::endl;
			else
			 rich = true;
		}
		else if (arg == "-v")
		{
			if (rich
				|| g6)
				std::cout << "Warning: " << arg << " will be ignored since another view format was already specified." << std::endl;
			else
				visualisation = true;
		}
		else if (arg == "-g6")
		{
			if (rich
				|| visualisation)
				std::cout << "Warning: " << arg << " will be ignored since another view format was already specified." << std::endl;
			else
				g6 = true;
		}
		else{
			file_name = arg + ".view";
			std::ifstream test(file_name);

			if (test.is_open())
			{
				std::cout << file_name << " already exists. Override? (y/n)\n>> ";
				std::string extra_input;
				while (true)
				{
					getline(std::cin, extra_input);
					if (extra_input == "y")
						break;
					if (extra_input == "n")
					{
						test.close();
						return;
					}
					std::cout << "Parse error: Not a valid input.\n>> ";
				}
			}

			test.close();
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	std::ofstream file(file_name, std::ios::trunc);

	if (!file.is_open())
	{
		std::cout << "Saving view failed. Could not open " << file_name << "." << std::endl;
		return;
	}

	if (rich)
		dbi->save_view_rich(&file);
	else if (visualisation)
		dbi->save_view_visualisation(&file);
	else if (g6)
		dbi->save_view_g6(&file);
	else
		dbi->save_view(&file);

	file.close();

	if (visualisation
		|| g6)
		std::cout << "Saved graphs in current view to " << file_name << "." << std::endl;
	else
		std::cout << "Saved current view to " << file_name << "." << std::endl;
}


/**
 * issues the type-update query to the database
**/
bool commission_type_update(DatabaseInterface * dbi, const char * print_name, const char * type, Graph_test test, const char * query_condition) {
	std::cout << "   checking for " << print_name << "...\n";
	if (dbi->update_type(test, type, query_condition))
		return true;
	else
		return false;
}


/**
* parses the arguments for insert
**/
void insert_parse(DatabaseInterface * dbi, std::string * input) {
	FORMAT format = FORMAT::NONE;
	std::string filename = "";

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (input->front() == '"')
		{
			arg = input->substr(1, std::string::npos);
			cut_index = arg.find_first_of('"');

			if (cut_index == std::string::npos)
			{
				std::cout << "Parse error: Second '\"' missing." << std::endl;
				return;
			}

			arg = arg.substr(0, cut_index);
			cut_index += 2;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);
		}

		if (arg == "-g6")
		{
			if (format == FORMAT::NONE)
				format = FORMAT::G6;
			else
			{
				std::cout << "Parse error: Format already specified." << std::endl;
				return;
			}
		}
		else if (arg == "-list")
		{
			if (format == FORMAT::NONE)
				format = FORMAT::LIST;
			else
			{
				std::cout << "Parse error: Format already specified." << std::endl;
				return;
			}
		}
		else
		{
			if (filename.empty())
				filename = arg;
			else
			{
				std::cout << "Parse error: Either an argument is invalid or there are too many." << std::endl;
				return;
			}
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (format == FORMAT::NONE)
	{
		std::cout << "Inserting graphs failed. No format specified." << std::endl;
		return;
	}

	std::ifstream file(filename);
	if (file.is_open())
	{
		try
		{
			std::cout << "   inserting graphs...\n";
			dbi->insert_graphs(&file, format);

		}
		catch (const char * e)
		{
			std::cerr << e << std::endl;
		}
	}
	else
	{
		std::cout << "Inserting graphs failed. Unable to open '" << filename << "'." << std::endl;
		return;
	}
	file.close();
}


/**
* parses the arguments for betti
**/
void betti_parse(DatabaseInterface * dbi, std::string * input) {
	int scriptID = -1;

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		cut_index = input->find_first_of(' ');
		arg = input->substr(0, cut_index);

		if (arg.front() != '-')
		{
			std::cout << "Parse Error: '" << arg << "' is not a valid argument." << std::endl;
			return;
		}

		if (scriptID == -1)
		{
			scriptID = 0;
			for (unsigned i = 1; i < arg.length(); i++)
			{
				if (arg.at(i) < '0'
					|| arg.at(i) > '9')
				{
					std::cout << "Parse error: '" << arg << "' is not a valid argument." << std::endl;
					return;
				}

				scriptID *= 10;
				scriptID += arg.at(i) - '0';
			}
		}
		else
		{
			std::cout << "Parse error: Too many arguments." << std::endl;
			return;
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (scriptID == -1)
	{
		dbi->show_scripts();

		std::cout << "Please select a scriptID to add the results of those M2 scripts.\n\n>> ";
		std::string arg;
		if (!getline(std::cin, arg))
			return;

		std::cout << std::endl;

		scriptID = 0;
		for (unsigned i = 0; i < arg.length(); i++)
		{
			if (arg.at(i) < '0'
				|| arg.at(i) > '9')
			{
				std::cout << "Parse error: '" << arg << "' is not a number." << std::endl;
				return;
			}

			scriptID *= 10;
			scriptID += arg.at(i) - '0';
		}
	}

	std::cout << "   adding Betti data...\n";
	dbi->add_betti_data(scriptID);
}


/**
 * parses the arguments for label
**/
void label_parse(DatabaseInterface * dbi, std::string * input) {
	bool allexcept = false;
	std::vector<bool> to_be_labeled;
	bool condition = false;
	std::string query_condition = "";

	for (int i = 0; i < NUMBER_TYPES; i++)
		to_be_labeled.push_back(false);

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (condition)
		{
			if (input->front() == '"')
			{
				arg = input->substr(1, std::string::npos);
				cut_index = arg.find_first_of('"');

				if (cut_index == std::string::npos)
				{
					std::cout << "Parse error: Second '\"' missing." << std::endl;
					return;
				}

				query_condition = arg.substr(0, cut_index);
				cut_index += 2;
			}
			else
			{
				std::cout << "Parse error: '-where' must be followed by an sql-expression in quotation marks (\"\")." << std::endl;
				return;
			}

			condition = false;
		}
		else
		{
			cut_index = input->find_first_of(' ');
			arg = input->substr(0, cut_index);

			if (arg == "-allexcept")
				allexcept = true;
			else if (arg == "-where")
				condition = true;
			else
			{
				int i;
				for (i = 0; i < NUMBER_TYPES; i++)
				{
					if (arg == "-" + std::string(TYPES[i]))
					{
						to_be_labeled[i] = true;
						break;
					}
				}

				if (i >= NUMBER_TYPES)
				{
					std::cout << "Parse error: '" << arg << "' is not a valid argument." << std::endl;
					return;
				}
			}
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (allexcept)
	{
		for (int i = 0; i < NUMBER_TYPES; i++)
			to_be_labeled[i] = !to_be_labeled[i];
	}

	for (int i = 0; i < NUMBER_TYPES; i++)
	{
		if (to_be_labeled[i])
		{
			if (STD_CONDITIONS[i])
				commission_type_update(dbi, PRINT_NAMES[i], TYPES[i], TESTS[i], query_condition.empty() ? STD_CONDITIONS[i] : (std::string(STD_CONDITIONS[i]) + " AND " + query_condition).c_str());
			else
				commission_type_update(dbi, PRINT_NAMES[i], TYPES[i], TESTS[i], query_condition.empty() ? 0 : query_condition.c_str());
		}
	}
}


/**
 * parses the arguments for gen_M2_scripts and calls gen_m2_scripts with the appropriate arguments
**/
void script_parse(DatabaseInterface * dbi, std::string * input) {
	bool condition = false;
	int batch_size = -1;
	int labeling = -1;
	std::string idealname = "";
	std::string filename = "";
	std::string query_condition = "";

	while (!input->empty())
	{
		size_t cut_index;
		std::string arg;

		if (condition)
		{
			if (input->front() == '"')
			{
				arg = input->substr(1, std::string::npos);
				cut_index = arg.find_first_of('"');

				if (cut_index == std::string::npos)
				{
					std::cout << "Parse error: '\"' missing." << std::endl;
					return;
				}

				query_condition = arg.substr(0, cut_index);
				cut_index += 2;
			}
			else
			{
				std::cout << "Parse error: '-where' must be followed by an sql-expression in quotation marks (\"\")." << std::endl;
				return;
			}

			condition = false;
		}
		else
		{
			if (input->front() == '"')
			{
				arg = input->substr(1, std::string::npos);
				cut_index = arg.find_first_of('"');

				if (cut_index == std::string::npos)
				{
					std::cout << "Parse error: '\"' missing." << std::endl;
					return;
				}

				arg = arg.substr(0, cut_index);
				cut_index += 2;
			}
			else
			{
				cut_index = input->find_first_of(' ');
				arg = input->substr(0, cut_index);
			}

			if (arg == "-where")
				condition = true;
			else if (arg.front() == '-')
			{
				for (int i = 0; i < NUMBER_LABELINGS; i++)
				{
					if (arg == "-" + std::string(LABELINGS[i]))
					{
						labeling = i;
						break;
					}
				}

				if (labeling == -1)
				{
					batch_size = 0;
					for (unsigned i = 1; i < arg.length(); i++)
					{
						if (arg.at(i) < '0'
							|| arg.at(i) > '9')
						{
							std::cout << "Parse error: " << arg << " is not a valid argument." << std::endl;
							return;
						}

						batch_size *= 10;
						batch_size += arg.at(i) - '0';
					}
				}
			}
			else if (idealname.empty())
				idealname = arg;
			else
				filename = arg;
		}

		if (cut_index < input->length() - 1)
			*input = input->substr(cut_index + 1, std::string::npos);
		else
			*input = "";
	}

	if (idealname.empty())
	{
		std::cout << "Generating M2 scripts failed. No ideal name specified.\n" << std::endl;
		return;
	}

	if (idealname.find("Bettis") == std::string::npos)
	{
		dbi->generate_m2_scripts(&idealname, labeling == -1 ? 0 : GENERATORS[labeling], batch_size == -1 ? 2500 : batch_size, query_condition.empty() ? 0 : query_condition.c_str(), filename.empty() ? 0 : filename.c_str(), labeling == -1 ? 0 : LABELINGS[labeling]);
	}
	else
		std::cout << "Generating M2 scripts failed. Please choose an ideal name other than " << idealname << " as anything with 'Bettis' in it would interfere with the database." << std::endl;
}


//########## main function ##########
/**
 * opens the given database (if none is specified it opens 'Graphs.db'),
 * gets the interaction key via io_interface and takes action based on the key
**/
int main(int argc, char* argv[]) {
	std::cout << "Graphs database interface\nEnter 'help' for a description of all features\n" << std::endl;

	std::string input = "";
	DatabaseInterface dbi;

	if (argc == 2)
		dbi = DatabaseInterface(argv[1]);
	else if (argc > 2)
	{
		std::cerr << "Too many arguments." << std::endl;
		return 1;
	}
	else
		dbi = DatabaseInterface("Graphs.db");

	dbi.create_status_table();
	dbi.create_scripts_table();
	dbi.create_graphs_table();

	while (true)
	{
		int key = io_interface(&input);

		switch (key)
		{
		case 0: return 0;
		case -2: dbi.execute_SQL_statement(&input); break;
		case -1: dbi.execute_SQL_query(&input); break;
		case 1: help_parse(&dbi, &input); break;
		case 2: show_parse(&dbi, &input); break;
		case 3: save_parse(&dbi, &input); break;
		case 4: insert_parse(&dbi, &input); break;
		case 5: label_parse(&dbi, &input); break;
		case 6: betti_parse(&dbi, &input); break;
		case 7: script_parse(&dbi, &input); break;
		default: break;
		}
	}
}