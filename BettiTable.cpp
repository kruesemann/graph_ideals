#include "BettiTable.h"


//########## helper functions ##########
/**
* returns 0 if x < 0 and x otherwise
**/
unsigned ignore_negative(int x) {
	return x < 0 ? 0 : x;
}


//########## public member functions ##########
/**
 * expects a file where Betti tables are parsed as generated by a previously generated Macaulay2 script. The following is an example of such a file:
 *        0 1 2		//The content of this line is ignored
 * total: 1 2 1		//The content of this line is ignored
 *     0: 1 . .
 *     1: . 2 .
 *     2: . . 1
 *
 *        0 1 2
 * total: 1 3 2
 *     0: 1 . .
 *     1: . 3 2
 *
 *
**/
bool BettiTable::read_next_table(std::ifstream* file) {
	std::string line = "";
	while (getline(*file, line) && line.empty());

	if (!getline(*file, line) || line.empty())
		return false;

	columns = 0;
	table = {};

	unsigned current_columns;

	while (getline(*file, line) && !line.empty())
	{
		line = line.substr(line.find_first_of(':') + 2, std::string::npos);
		current_columns = 0;

		for (unsigned i = 0; i < line.length();)
		{
			unsigned betti_number = 0;

			while (i < line.length()
				&& line.at(i) != ' ')
			{
				if (line.at(i) != '.')
				{
					if (line.at(i) < '0'
						|| line.at(i) > '9')
					{
						PARSE_ERROR("'" << line.at(i) << "' is not a number.");
						FAIL("Adding Betti data", "");
						return false;
					}

					betti_number *= 10;
					betti_number += line.at(i) - '0';
				}
				i++;
			}

			table.push_back(betti_number);
			current_columns++;

			while (i < line.length()
				&& line.at(i) == ' ')
				i++;
		}

		if (columns == 0)
			columns = current_columns;
		else if (current_columns != columns)
		{
			PARSE_ERROR("The number of columns is not consistent.");
			FAIL("Adding Betti data", "");
			return false;
		}
	}

	return true;
}


/**
 * expects a string where the Betti table is parsed like this: "{1,0,0},{0,2,0},{0,0,1}"
**/
void BettiTable::read_from_line(std::string * line) {
	columns = 0;
	table = {};
	unsigned rows = 0;

	if (*line == "-"
		|| line->empty())
		return;
	
	for (unsigned i = 0; i < line->length(); i += 2)
	{
		if (line->at(i) != '{')
		{
			PARSE_ERROR("Expected '{', got '" << line->at(i) << "' instead.");
			FAIL("Reading Betti table", "");
			return;
		}

		while (i < line->length()
			&& line->at(i) != '}')
		{
			i++;

			unsigned betti_number = 0;

			while (i < line->length()
				&& line->at(i) != ','
				&& line->at(i) != '}')
			{
				if (line->at(i) < '0'
					|| line->at(i) > '9')
				{
					PARSE_ERROR("'" << line->at(i) << "' is not a number.");
					FAIL("Reading Betti table", "");
					return;
				}

				betti_number *= 10;
				betti_number += line->at(i) - '0';
				i++;
			}

			table.push_back(betti_number);
		}

		if (i == line->length())
		{
			PARSE_ERROR("Line incomplete.");
			FAIL("Reading Betti table", "");
			return;
		}

		rows++;
	}

	columns = table.size() / rows;
}


/**
 * converts the Betti table to a list of its rows
**/
std::string BettiTable::convert_to_line() {
	if (columns == 0)
		return "";

	std::string str = "{";
	unsigned rows = table.size() / columns;

	for (unsigned i = 0; i < rows; i++)
	{
		for (unsigned j = 0; j < columns; j++)
			str += std::to_string(table[(columns * i) + j]) + ",";

		if (!str.empty())
			str.pop_back();

		str += "},{";
	}

	if (!str.empty())
	{
		str.pop_back();
		str.pop_back();
	}

	return str;
}


/**
 * returns the projective dimension
**/
unsigned BettiTable::get_projective_dimension() {
	return columns - 1;
}


/**
 * returns the Castelnuovo-Mumford regularity
**/
unsigned BettiTable::get_regularity() {
	return (table.size() / columns) - 1;
}


/**
 * returns a list of the Betti numbers where every other Betti number to the right and down from these is zero
**/
std::vector<unsigned> BettiTable::get_extremal_betti_numbers() {
	if (columns == 0)
		return {};

	std::vector<unsigned> extremal_betti_numbers = {};

	unsigned size = table.size();

	unsigned last = columns;

	for (unsigned row_to_last = 0; row_to_last < size / columns; row_to_last++)
	{
		for (unsigned i = 1; i <= last; i++)
		{
			if (table[size - (row_to_last * columns) - i] != 0)
			{
				extremal_betti_numbers.push_back(table[size - (row_to_last * columns) - i]);
				last = i - 1;
				break;
			}
		}
	}

	return extremal_betti_numbers;
}


/**
* returns a string-list of the Betti numbers where every other Betti number to the right and down from these is zero
**/
std::string BettiTable::get_extremal_betti_numbers_as_string() {
	std::vector<unsigned> extremal_betti_numbers = get_extremal_betti_numbers();
	std::string str = "";

	for (unsigned i = 0; i < extremal_betti_numbers.size(); i++)
		str += std::to_string(extremal_betti_numbers[i]) + ",";

	if (!str.empty())
		str.pop_back();

	return str;
}


/**
 * computes the widths of the columns as a string
**/
std::vector<unsigned> BettiTable::get_column_widths() {
	if (columns == 0)
		return {};

	std::vector<unsigned> widths;
	unsigned column_width;
	unsigned current_width;

	for (unsigned j = 0; j < columns; j++)
	{
		column_width = 0;
		for (unsigned i = 0; i < table.size() / columns; i++)
		{
			current_width = (unsigned)log10(table[i * columns + j]) + 1;
			if (column_width < current_width)
				column_width = current_width;
			unsigned label_width = (unsigned)log10(j) + 1;
			if (column_width < label_width)
				column_width = label_width;
		}

		widths.push_back(column_width);
	}

	return widths;
}


//########## public static functions ##########
/**
 * writes tables next to each other in a string 
**/
std::string BettiTable::convert_tables_to_string(std::vector<BettiTable> * tables, std::vector<std::string> * table_names) {
	std::vector<std::string> lines;
	int overall_width = 0;

	for (unsigned table_number = 0; table_number < tables->size(); table_number++)
	{
		BettiTable b = tables->at(table_number);
		std::vector<unsigned> column_widths = b.get_column_widths();

		if (b.columns == 0)
		{
			//add more rows to lines if necessary
			int old_size = lines.size();
			for (unsigned i = 0; i < ignore_negative(2 - old_size); i++)
				lines.push_back("");

			//add appropriate whitespace to separate the tables
			for (unsigned i = 0; i < lines.size(); i++)
				lines[i] += std::string(ignore_negative(overall_width - lines[i].length()), ' ');

			//add table name to lines and indicate missing table
			lines[0] += table_names->at(table_number);
			lines[1] += '-';

			//update overall_width
			if (overall_width < (int)lines[0].length())
				overall_width = lines[0].length();

			if (overall_width < (int)lines[1].length())
				overall_width = lines[1].length();

			overall_width += 3;
		}
		else
		{
			//add more rows to lines if necessary
			int old_size = lines.size();
			for (unsigned i = 0; i < ignore_negative(b.table.size() / b.columns + 2 - old_size); i++)
				lines.push_back("");

			//add appropriate whitespace to separate the tables
			for (unsigned i = 0; i < lines.size(); i++)
				lines[i] += std::string(ignore_negative(overall_width - lines[i].length()), ' ');

			//add table name to first line
			lines[0] += table_names->at(table_number);

			//update overall_width
			if (overall_width < (int)lines[0].length())
				overall_width = lines[0].length();

			//add label row to second line
			unsigned row_label_width = ignore_negative((int)log10(b.table.size() / b.columns - 1)) + 2;
			lines[1] += std::string(row_label_width, ' ');

			for (unsigned j = 0; j < b.columns; j++)
				lines[1] += std::string(ignore_negative(column_widths[j] - ignore_negative((int)log10(j))), ' ') + std::to_string(j);

			//update overall_width
			if (overall_width < (int)lines[1].length())
				overall_width = lines[1].length();

			//add table contents to lines
			for (unsigned i = 0; i < b.table.size() / b.columns; i++)
			{
				lines[i + 2] += std::to_string(i) + ':' + std::string(ignore_negative(row_label_width - ignore_negative((int)log10(i)) - 2), ' ');

				for (unsigned j = 0; j < b.columns; j++)
				{
					unsigned entry = b.table[i * b.columns + j];
					std::string betti_number;
					if (entry == 0)
						betti_number = ".";
					else
						betti_number = std::to_string(entry);
					lines[i + 2] += std::string(ignore_negative(column_widths[j] + 1 - betti_number.length()), ' ') + betti_number;
				}

				//update overall_width
				if (overall_width < (int)lines[i + 2].length())
					overall_width = lines[i + 2].length();
			}

			overall_width += 3;
		}
	}

	std::string str = "";

	for (unsigned i = 0; i < lines.size(); i++)
		str += lines[i] + '\n';

	return str;
}